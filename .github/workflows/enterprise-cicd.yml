name: Enterprise CI/CD - Docker Hub â†’ AWS ECS

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  workflow_dispatch:

env:
  AWS_REGION: ap-northeast-1
  DOCKER_REPOSITORY: lks0426/lks0426-portfolio
  ECS_CLUSTER: lks0426-portfolio-dev
  ECS_SERVICE: lks0426-portfolio-dev
  DOMAIN_NAME: lks0426.com

jobs:
  # é˜¶æ®µ1ï¼šä»£ç è´¨é‡æ£€æŸ¥
  quality-check:
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.quality-decision.outputs.should-deploy }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --frozen-lockfile

      - name: Run linter
        run: npm run lint

      - name: Run type checking
        run: npm run type-check

      - name: Run tests
        run: npm test -- --coverage --watchAll=false
        env:
          CI: true

      - name: Build application
        run: npm run build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL || 'placeholder' }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'placeholder' }}

      - name: Quality gate decision
        id: quality-decision
        run: |
          echo "âœ… All quality checks passed"
          echo "should-deploy=true" >> $GITHUB_OUTPUT

  # é˜¶æ®µ2ï¼šæ„å»ºå’Œæ¨é€Dockeré•œåƒ
  build-and-push-image:
    needs: quality-check
    if: needs.quality-check.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
      image-uri: ${{ steps.build.outputs.image-uri }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME || 'lks0426' }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push image
        id: build
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          COMMIT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="${TIMESTAMP}-${COMMIT_SHA}"
          IMAGE_URI="${{ env.DOCKER_REPOSITORY }}:${IMAGE_TAG}"
          LATEST_URI="${{ env.DOCKER_REPOSITORY }}:latest"
          
          echo "ğŸ³ Building Docker image with cache..."
          docker buildx build \
            --platform linux/amd64 \
            --cache-from type=gha \
            --cache-to type=gha,mode=max \
            -f Dockerfile.optimized \
            -t $IMAGE_URI \
            -t $LATEST_URI \
            --push .
          
          echo "âœ… Images built and pushed with buildx cache"
          
          echo "âœ… Image pushed: $IMAGE_URI"
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT

  # é˜¶æ®µ3ï¼šé•œåƒè´¨é‡éªŒè¯ï¼ˆå…³é”®è´¨é‡é—¨æ§ï¼‰
  verify-image:
    needs: build-and-push-image
    runs-on: ubuntu-latest
    outputs:
      image-verified: ${{ steps.verify.outputs.verified }}
    
    steps:
      - name: Pull and test image
        id: verify
        run: |
          IMAGE_URI="${{ needs.build-and-push-image.outputs.image-uri }}"
          
          echo "ğŸ” Pulling image: $IMAGE_URI"
          docker pull $IMAGE_URI
          
          echo "ğŸ§ª Starting image verification..."
          # å¯åŠ¨å®¹å™¨è¿›è¡Œæµ‹è¯•
          docker run -d -p 3000:3000 --name test-app $IMAGE_URI
          
          # ç­‰å¾…åº”ç”¨å¯åŠ¨
          echo "â³ Waiting for application to start..."
          sleep 30
          
          # å¥åº·æ£€æŸ¥
          echo "ğŸ¥ Health check..."
          if curl -f http://localhost:3000/ > /dev/null 2>&1; then
            echo "âœ… Health check passed"
          else
            echo "âŒ Health check failed"
            docker logs test-app
            exit 1
          fi
          
          # æ€§èƒ½æµ‹è¯•
          echo "âš¡ Performance test..."
          response_time=$(curl -o /dev/null -s -w "%{time_total}" http://localhost:3000/)
          echo "Response time: ${response_time}s"
          
          if (( $(echo "$response_time < 5.0" | bc -l) )); then
            echo "âœ… Performance test passed"
          else
            echo "âŒ Performance test failed: too slow (${response_time}s)"
            exit 1
          fi
          
          # æ¸…ç†
          docker stop test-app
          docker rm test-app
          
          echo "âœ… Image verification successful!"
          echo "verified=true" >> $GITHUB_OUTPUT

  # é˜¶æ®µ4ï¼šAWS ECSéƒ¨ç½²ï¼ˆåªæœ‰é•œåƒéªŒè¯é€šè¿‡æ‰æ‰§è¡Œï¼‰
  deploy-to-ecs:
    needs: [build-and-push-image, verify-image]
    if: needs.verify-image.outputs.image-verified == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check ECS infrastructure
        id: check-infra
        run: |
          echo "ğŸ” Checking ECS infrastructure..."
          
          # æ£€æŸ¥ECSé›†ç¾¤æ˜¯å¦å­˜åœ¨
          if aws ecs describe-clusters --clusters ${{ env.ECS_CLUSTER }} --region ${{ env.AWS_REGION }} --query 'clusters[0].status' --output text 2>/dev/null | grep -q "ACTIVE"; then
            echo "âœ… ECS cluster exists and is active"
            echo "cluster-exists=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ ECS cluster not found or not active"
            echo "cluster-exists=false" >> $GITHUB_OUTPUT
          fi
          
          # æ£€æŸ¥ECSæœåŠ¡æ˜¯å¦å­˜åœ¨
          if aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --region ${{ env.AWS_REGION }} --query 'services[0].status' --output text 2>/dev/null | grep -q "ACTIVE"; then
            echo "âœ… ECS service exists and is active"
            echo "service-exists=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ ECS service not found or not active"
            echo "service-exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to ECS
        if: steps.check-infra.outputs.cluster-exists == 'true' && steps.check-infra.outputs.service-exists == 'true'
        run: |
          IMAGE_URI="${{ needs.build-and-push-image.outputs.image-uri }}"
          
          echo "ğŸš€ Deploying verified image to ECS: $IMAGE_URI"
          
          # è·å–å½“å‰ä»»åŠ¡å®šä¹‰
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition' \
            --output json | jq --arg IMAGE "$IMAGE_URI" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          # æ³¨å†Œæ–°ä»»åŠ¡å®šä¹‰
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --region ${{ env.AWS_REGION }} \
            --cli-input-json "$TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "ğŸ“ New task definition: $NEW_TASK_DEF"
          
          # æ›´æ–°ECSæœåŠ¡
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition "$NEW_TASK_DEF" \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… ECS service update initiated"

      - name: Wait for deployment
        if: steps.check-infra.outputs.cluster-exists == 'true' && steps.check-infra.outputs.service-exists == 'true'
        run: |
          echo "â³ Waiting for ECS deployment to complete..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… ECS deployment completed successfully!"

      - name: Infrastructure setup needed
        if: steps.check-infra.outputs.cluster-exists != 'true' || steps.check-infra.outputs.service-exists != 'true'
        run: |
          echo "âš ï¸ AWS ECS infrastructure is not ready"
          echo "ğŸ“‹ Next steps:"
          echo "   1. Deploy AWS infrastructure using CDK"
          echo "   2. Ensure ECS cluster and service are created"
          echo "   3. Re-run this workflow"
          echo ""
          echo "ğŸ”§ To deploy infrastructure:"
          echo "   cd infrastructure/aws-cdk && npm run deploy"

  # é˜¶æ®µ5ï¼šéƒ¨ç½²åéªŒè¯
  post-deployment-test:
    needs: [deploy-to-ecs]
    if: success()
    runs-on: ubuntu-latest
    
    steps:
      - name: Test deployed application
        run: |
          echo "ğŸ§ª Testing deployed application..."
          
          # ç­‰å¾…éƒ¨ç½²å®Œæˆ
          sleep 60
          
          # æµ‹è¯•ç½‘ç«™æ˜¯å¦å¯è®¿é—®
          if curl -f "https://${{ env.DOMAIN_NAME }}/" > /dev/null 2>&1; then
            echo "âœ… Website is accessible at https://${{ env.DOMAIN_NAME }}"
          else
            echo "âš ï¸ Website not yet accessible (may need DNS propagation)"
          fi
          
          echo "ğŸ‰ Deployment pipeline completed successfully!"